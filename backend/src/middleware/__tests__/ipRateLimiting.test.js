/**\n * IP-Based Rate Limiting Integration Test\n * \n * Tests IP extraction, rate limiting by IP, and multi-IP scenarios.\n */\n\nconst request = require('supertest');\nconst express = require('express');\nconst { createRateLimiterMiddleware, extractClientIP } = require('../rateLimiter');\nconst { connectRedis, getRedisClient } = require('../../config/redis');\n\nclass IPRateLimitTester {\n  constructor() {\n    this.app = express();\n    this.redis = null;\n    this.testResults = {\n      totalTests: 0,\n      passed: 0,\n      failed: 0,\n      errors: [],\n    };\n  }\n\n  async setup() {\n    // Connect to Redis\n    await connectRedis();\n    this.redis = getRedisClient();\n    \n    // Setup test express app with IP-based rate limiting\n    this.app.set('trust proxy', true); // Important for correct IP extraction\n    \n    // Create IP-based rate limiter: 5 requests per minute\n    const ipRateLimit = createRateLimiterMiddleware({\n      keyPrefix: 'test_ip_limit',\n      points: 5,\n      duration: 60,\n      identifierType: 'ip',\n    });\n    \n    this.app.use(ipRateLimit);\n    \n    this.app.get('/test', (req, res) => {\n      res.json({\n        success: true,\n        message: 'Request successful',\n        ip: extractClientIP(req),\n        timestamp: new Date().toISOString(),\n      });\n    });\n    \n    // Clear test data\n    const keys = await this.redis.keys('test_ip_limit:*');\n    if (keys.length > 0) {\n      await this.redis.del(...keys);\n    }\n  }\n\n  async testBasicIPRateLimit() {\n    console.log('\\nðŸ§ª Testing basic IP-based rate limiting...');\n    \n    try {\n      const testIP = '203.0.113.100';\n      \n      // Test 1: First request should succeed\n      const response1 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', testIP)\n        .expect(200);\n      \n      this.assert(\n        response1.headers['x-ratelimit-limit'] === '5',\n        'Rate limit header should show limit of 5',\n        response1.headers['x-ratelimit-limit']\n      );\n      \n      this.assert(\n        response1.headers['x-ratelimit-remaining'] === '4',\n        'Remaining should be 4 after first request',\n        response1.headers['x-ratelimit-remaining']\n      );\n      \n      // Test 2: Consume remaining points\n      for (let i = 0; i < 4; i++) {\n        await request(this.app)\n          .get('/test')\n          .set('X-Forwarded-For', testIP)\n          .expect(200);\n      }\n      \n      // Test 3: Next request should be rate limited\n      const rateLimitedResponse = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', testIP)\n        .expect(429);\n      \n      this.assert(\n        rateLimitedResponse.body.error.code === 'RATE_LIMIT_EXCEEDED',\n        'Should return RATE_LIMIT_EXCEEDED error',\n        rateLimitedResponse.body.error.code\n      );\n      \n      this.assert(\n        rateLimitedResponse.headers['retry-after'],\n        'Should include Retry-After header',\n        rateLimitedResponse.headers['retry-after']\n      );\n      \n      console.log('âœ… Basic IP rate limiting test passed');\n      \n    } catch (error) {\n      this.fail(`Basic IP rate limiting test failed: ${error.message}`);\n    }\n  }\n\n  async testMultipleIPs() {\n    console.log('\\nðŸ§ª Testing multiple IP isolation...');\n    \n    try {\n      const ip1 = '203.0.113.101';\n      const ip2 = '203.0.113.102';\n      const ip3 = '203.0.113.103';\n      \n      // Each IP should have independent rate limits\n      const response1 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', ip1)\n        .expect(200);\n      \n      const response2 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', ip2)\n        .expect(200);\n      \n      const response3 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', ip3)\n        .expect(200);\n      \n      // All should have 4 remaining since they're different IPs\n      this.assert(\n        response1.headers['x-ratelimit-remaining'] === '4',\n        'IP1 should have 4 remaining',\n        response1.headers['x-ratelimit-remaining']\n      );\n      \n      this.assert(\n        response2.headers['x-ratelimit-remaining'] === '4',\n        'IP2 should have 4 remaining',\n        response2.headers['x-ratelimit-remaining']\n      );\n      \n      this.assert(\n        response3.headers['x-ratelimit-remaining'] === '4',\n        'IP3 should have 4 remaining',\n        response3.headers['x-ratelimit-remaining']\n      );\n      \n      console.log('âœ… Multiple IP isolation test passed');\n      \n    } catch (error) {\n      this.fail(`Multiple IP isolation test failed: ${error.message}`);\n    }\n  }\n\n  async testXForwardedForHandling() {\n    console.log('\\nðŸ§ª Testing X-Forwarded-For header handling...');\n    \n    try {\n      // Test 1: Single IP in X-Forwarded-For\n      const response1 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', '203.0.113.200')\n        .expect(200);\n      \n      this.assert(\n        response1.body.ip === '203.0.113.200',\n        'Should extract single IP correctly',\n        response1.body.ip\n      );\n      \n      // Test 2: Multiple IPs in X-Forwarded-For (should use first valid public IP)\n      const response2 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', '192.168.1.100, 203.0.113.201, 10.0.0.1')\n        .expect(200);\n      \n      // In production mode, should skip private IPs and use first public IP\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'production';\n      \n      const response3 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', '192.168.1.100, 203.0.113.202')\n        .expect(200);\n      \n      process.env.NODE_ENV = originalEnv;\n      \n      // Test 3: Invalid IPs should fallback gracefully\n      const response4 = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', 'invalid-ip, not-an-ip')\n        .expect(200);\n      \n      console.log('âœ… X-Forwarded-For handling test passed');\n      \n    } catch (error) {\n      this.fail(`X-Forwarded-For handling test failed: ${error.message}`);\n    }\n  }\n\n  async testIPv6Support() {\n    console.log('\\nðŸ§ª Testing IPv6 support...');\n    \n    try {\n      const ipv6 = '2001:0db8:85a3:0000:0000:8a2e:0370:7334';\n      \n      const response = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', ipv6)\n        .expect(200);\n      \n      this.assert(\n        response.body.ip === ipv6,\n        'Should handle IPv6 correctly',\n        response.body.ip\n      );\n      \n      // Rate limiting should work with IPv6\n      for (let i = 0; i < 4; i++) {\n        await request(this.app)\n          .get('/test')\n          .set('X-Forwarded-For', ipv6)\n          .expect(200);\n      }\n      \n      await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', ipv6)\n        .expect(429);\n      \n      console.log('âœ… IPv6 support test passed');\n      \n    } catch (error) {\n      this.fail(`IPv6 support test failed: ${error.message}`);\n    }\n  }\n\n  async testRateLimitHeaders() {\n    console.log('\\nðŸ§ª Testing rate limit headers...');\n    \n    try {\n      const testIP = '203.0.113.300';\n      \n      const response = await request(this.app)\n        .get('/test')\n        .set('X-Forwarded-For', testIP)\n        .expect(200);\n      \n      // Verify all required headers are present\n      const requiredHeaders = [\n        'x-ratelimit-limit',\n        'x-ratelimit-remaining', \n        'x-ratelimit-reset',\n        'x-ratelimit-window',\n      ];\n      \n      requiredHeaders.forEach(header => {\n        this.assert(\n          response.headers[header] !== undefined,\n          `Header ${header} should be present`,\n          response.headers[header]\n        );\n      });\n      \n      // Verify header values are correct\n      const limit = parseInt(response.headers['x-ratelimit-limit']);\n      const remaining = parseInt(response.headers['x-ratelimit-remaining']);\n      const reset = parseInt(response.headers['x-ratelimit-reset']);\n      const window = response.headers['x-ratelimit-window'];\n      \n      this.assert(limit === 5, 'Limit should be 5', limit);\n      this.assert(remaining === 4, 'Remaining should be 4', remaining);\n      this.assert(reset > Date.now() / 1000, 'Reset time should be in the future', reset);\n      this.assert(window === '60s', 'Window should be 60s', window);\n      \n      console.log('âœ… Rate limit headers test passed');\n      \n    } catch (error) {\n      this.fail(`Rate limit headers test failed: ${error.message}`);\n    }\n  }\n\n  // Helper methods\n  assert(condition, message, actual) {\n    this.testResults.totalTests++;\n    if (condition) {\n      this.testResults.passed++;\n      console.log(`  âœ“ ${message}`);\n    } else {\n      this.testResults.failed++;\n      const error = `${message} (got: ${actual})`;\n      console.log(`  âœ— ${error}`);\n      this.testResults.errors.push(error);\n    }\n  }\n\n  fail(message) {\n    this.testResults.totalTests++;\n    this.testResults.failed++;\n    console.log(`  âœ— ${message}`);\n    this.testResults.errors.push(message);\n  }\n\n  async cleanup() {\n    // Clean up test data\n    if (this.redis) {\n      const keys = await this.redis.keys('test_ip_limit:*');\n      if (keys.length > 0) {\n        await this.redis.del(...keys);\n      }\n    }\n  }\n\n  async runAllTests() {\n    console.log('ðŸš€ Starting IP-Based Rate Limiting Tests\\n');\n    \n    try {\n      await this.setup();\n      \n      await this.testBasicIPRateLimit();\n      await this.testMultipleIPs();\n      await this.testXForwardedForHandling();\n      await this.testIPv6Support();\n      await this.testRateLimitHeaders();\n      \n    } finally {\n      await this.cleanup();\n    }\n    \n    // Print results\n    console.log('\\nðŸ“Š IP Rate Limiting Test Results:');\n    console.log(`Total Tests: ${this.testResults.totalTests}`);\n    console.log(`Passed: ${this.testResults.passed}`);\n    console.log(`Failed: ${this.testResults.failed}`);\n    \n    if (this.testResults.errors.length > 0) {\n      console.log('\\nâŒ Errors:');\n      this.testResults.errors.forEach((error, index) => {\n        console.log(`${index + 1}. ${error}`);\n      });\n    }\n    \n    const success = this.testResults.failed === 0;\n    console.log(`\\n${success ? 'âœ…' : 'âŒ'} IP Rate Limiting Tests ${success ? 'PASSED' : 'FAILED'}`);\n    \n    return success;\n  }\n}\n\n// Run tests if called directly\nif (require.main === module) {\n  const tester = new IPRateLimitTester();\n  tester.runAllTests().then(success => {\n    process.exit(success ? 0 : 1);\n  }).catch(error => {\n    console.error('IP Rate Limiting test runner failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = IPRateLimitTester;