/**\n * Rate Limiter Sliding Window Counter Algorithm Tests\n * \n * Tests the implementation of sliding window counter logic used by rate-limiter-flexible.\n * Validates window overlap calculations, counter operations, and TTL management.\n */\n\nconst Redis = require('ioredis');\nconst { RateLimiterRedis } = require('rate-limiter-flexible');\nconst { connectRedis, getRedisClient, isRedisConnected } = require('../src/config/redis');\nconst logger = require('../src/utils/logger');\n\nclass SlidingWindowTester {\n  constructor() {\n    this.testResults = {\n      totalTests: 0,\n      passed: 0,\n      failed: 0,\n      errors: [],\n    };\n  }\n\n  /**\n   * Test basic sliding window counter functionality\n   */\n  async testBasicSlidingWindow() {\n    console.log('\\nðŸ§ª Testing basic sliding window counter...');\n    \n    try {\n      const rateLimiter = new RateLimiterRedis({\n        storeClient: getRedisClient(),\n        keyPrefix: 'test_basic_window',\n        points: 5, // Allow 5 requests\n        duration: 10, // Per 10 seconds\n      });\n\n      const testKey = 'test_user_123';\n      \n      // Clear any existing data\n      await getRedisClient().del(`test_basic_window:${testKey}`);\n      \n      // Test 1: First request should succeed\n      const result1 = await rateLimiter.consume(testKey);\n      this.assert(result1.remainingPoints === 4, 'First request should have 4 remaining points', result1.remainingPoints);\n      \n      // Test 2: Consume all remaining points\n      await rateLimiter.consume(testKey, 4);\n      \n      // Test 3: Next request should fail\n      try {\n        await rateLimiter.consume(testKey);\n        this.fail('Request should have been rate limited');\n      } catch (rateLimitError) {\n        this.assert(rateLimitError.remainingPoints === 0, 'Should have 0 remaining points when rate limited');\n      }\n      \n      console.log('âœ… Basic sliding window test passed');\n      \n    } catch (error) {\n      this.fail(`Basic sliding window test failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Test window overlap calculation\n   */\n  async testWindowOverlap() {\n    console.log('\\nðŸ§ª Testing window overlap calculation...');\n    \n    try {\n      const rateLimiter = new RateLimiterRedis({\n        storeClient: getRedisClient(),\n        keyPrefix: 'test_window_overlap',\n        points: 10,\n        duration: 30, // 30 second window\n      });\n\n      const testKey = 'overlap_test_user';\n      \n      // Clear any existing data\n      await getRedisClient().del(`test_window_overlap:${testKey}`);\n      \n      // Consume 5 points\n      await rateLimiter.consume(testKey, 5);\n      \n      // Wait 10 seconds (1/3 of window)\n      console.log('â³ Waiting 10 seconds to test window overlap...');\n      await this.sleep(10000);\n      \n      // Consume 3 more points  \n      const result = await rateLimiter.consume(testKey, 3);\n      \n      // Should have 2 remaining points (10 total - 5 - 3)\n      this.assert(result.remainingPoints === 2, 'Window overlap calculation should show 2 remaining points', result.remainingPoints);\n      \n      console.log('âœ… Window overlap test passed');\n      \n    } catch (error) {\n      this.fail(`Window overlap test failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Test Redis INCR operations and TTL\n   */\n  async testRedisOperations() {\n    console.log('\\nðŸ§ª Testing Redis operations and TTL...');\n    \n    try {\n      const redis = getRedisClient();\n      const testKey = 'test_redis_ops';\n      \n      // Clear any existing data\n      await redis.del(testKey);\n      \n      // Test 1: Basic INCR\n      const count1 = await redis.incr(testKey);\n      this.assert(count1 === 1, 'First INCR should return 1', count1);\n      \n      // Test 2: Set TTL\n      await redis.expire(testKey, 60);\n      const ttl = await redis.ttl(testKey);\n      this.assert(ttl > 0 && ttl <= 60, 'TTL should be set and positive', ttl);\n      \n      // Test 3: Multiple INCR operations\n      await redis.incr(testKey);\n      await redis.incr(testKey);\n      const finalCount = await redis.get(testKey);\n      this.assert(parseInt(finalCount) === 3, 'Final count should be 3', finalCount);\n      \n      // Test 4: Key expiration behavior\n      await redis.del(testKey);\n      await redis.setex(testKey, 1, '5'); // Set with 1 second TTL\n      await this.sleep(1100); // Wait for expiration\n      const expiredValue = await redis.get(testKey);\n      this.assert(expiredValue === null, 'Key should have expired', expiredValue);\n      \n      console.log('âœ… Redis operations test passed');\n      \n    } catch (error) {\n      this.fail(`Redis operations test failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Test counter logic validation\n   */\n  async testCounterLogic() {\n    console.log('\\nðŸ§ª Testing counter logic validation...');\n    \n    try {\n      const rateLimiter = new RateLimiterRedis({\n        storeClient: getRedisClient(),\n        keyPrefix: 'test_counter_logic',\n        points: 3,\n        duration: 5,\n      });\n\n      const testKey = 'logic_test_user';\n      \n      // Clear any existing data\n      await getRedisClient().del(`test_counter_logic:${testKey}`);\n      \n      // Test 1: Exact limit consumption\n      await rateLimiter.consume(testKey, 3);\n      \n      try {\n        await rateLimiter.consume(testKey, 1);\n        this.fail('Should not allow consumption beyond limit');\n      } catch (rateLimitError) {\n        this.assert(rateLimitError.remainingPoints === 0, 'Should have 0 remaining points');\n      }\n      \n      // Test 2: Partial consumption\n      await getRedisClient().del(`test_counter_logic:${testKey}`);\n      \n      const result1 = await rateLimiter.consume(testKey, 1);\n      this.assert(result1.remainingPoints === 2, 'Should have 2 remaining after consuming 1');\n      \n      const result2 = await rateLimiter.consume(testKey, 1);\n      this.assert(result2.remainingPoints === 1, 'Should have 1 remaining after consuming another 1');\n      \n      // Test 3: Over-consumption attempt\n      try {\n        await rateLimiter.consume(testKey, 2); // Try to consume 2 but only 1 remaining\n        this.fail('Should not allow over-consumption');\n      } catch (rateLimitError) {\n        // Should still have 1 remaining since the consumption failed\n        this.assert(rateLimitError.remainingPoints === 1, 'Failed consumption should not decrease counter');\n      }\n      \n      console.log('âœ… Counter logic test passed');\n      \n    } catch (error) {\n      this.fail(`Counter logic test failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Test rate limiter reset and recovery\n   */\n  async testResetAndRecovery() {\n    console.log('\\nðŸ§ª Testing reset and recovery...');\n    \n    try {\n      const rateLimiter = new RateLimiterRedis({\n        storeClient: getRedisClient(),\n        keyPrefix: 'test_reset_recovery',\n        points: 2,\n        duration: 3, // Short window for testing\n      });\n\n      const testKey = 'reset_test_user';\n      \n      // Clear any existing data\n      await getRedisClient().del(`test_reset_recovery:${testKey}`);\n      \n      // Consume all points\n      await rateLimiter.consume(testKey, 2);\n      \n      // Verify blocked\n      try {\n        await rateLimiter.consume(testKey);\n        this.fail('Should be blocked after consuming all points');\n      } catch (rateLimitError) {\n        console.log(`â³ Waiting ${rateLimitError.msBeforeNext}ms for window reset...`);\n        await this.sleep(rateLimitError.msBeforeNext + 100);\n      }\n      \n      // Should be able to consume again after reset\n      const result = await rateLimiter.consume(testKey);\n      this.assert(result.remainingPoints === 1, 'Should have 1 remaining point after reset', result.remainingPoints);\n      \n      console.log('âœ… Reset and recovery test passed');\n      \n    } catch (error) {\n      this.fail(`Reset and recovery test failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Helper methods\n   */\n  assert(condition, message, actual) {\n    this.testResults.totalTests++;\n    if (condition) {\n      this.testResults.passed++;\n      console.log(`  âœ“ ${message}`);\n    } else {\n      this.testResults.failed++;\n      const error = `${message} (got: ${actual})`;\n      console.log(`  âœ— ${error}`);\n      this.testResults.errors.push(error);\n    }\n  }\n\n  fail(message) {\n    this.testResults.totalTests++;\n    this.testResults.failed++;\n    console.log(`  âœ— ${message}`);\n    this.testResults.errors.push(message);\n  }\n\n  async sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Run all sliding window tests\n   */\n  async runAllTests() {\n    console.log('ðŸš€ Starting Sliding Window Counter Algorithm Tests\\n');\n    \n    // Ensure Redis is connected\n    if (!isRedisConnected()) {\n      await connectRedis();\n    }\n    \n    await this.testBasicSlidingWindow();\n    await this.testWindowOverlap();\n    await this.testRedisOperations();\n    await this.testCounterLogic();\n    await this.testResetAndRecovery();\n    \n    // Print results\n    console.log('\\nðŸ“Š Test Results:');\n    console.log(`Total Tests: ${this.testResults.totalTests}`);\n    console.log(`Passed: ${this.testResults.passed}`);\n    console.log(`Failed: ${this.testResults.failed}`);\n    \n    if (this.testResults.errors.length > 0) {\n      console.log('\\nâŒ Errors:');\n      this.testResults.errors.forEach((error, index) => {\n        console.log(`${index + 1}. ${error}`);\n      });\n    }\n    \n    const success = this.testResults.failed === 0;\n    console.log(`\\n${success ? 'âœ…' : 'âŒ'} Sliding Window Tests ${success ? 'PASSED' : 'FAILED'}`);\n    \n    return success;\n  }\n}\n\n// Run tests if called directly\nif (require.main === module) {\n  const tester = new SlidingWindowTester();\n  tester.runAllTests().then(success => {\n    process.exit(success ? 0 : 1);\n  }).catch(error => {\n    console.error('Test runner failed:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = SlidingWindowTester;